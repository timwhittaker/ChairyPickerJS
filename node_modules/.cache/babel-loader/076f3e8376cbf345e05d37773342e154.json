{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _has = _interopRequireDefault(require(\"lodash/has\"));\n\nvar _isSchema = _interopRequireDefault(require(\"./util/isSchema\"));\n\nfunction callOrConcat(schema) {\n  if (typeof schema === 'function') return schema;\n  return function (base) {\n    return base.concat(schema);\n  };\n}\n\nvar Conditional = /*#__PURE__*/function () {\n  function Conditional(refs, options) {\n    var is = options.is,\n        then = options.then,\n        otherwise = options.otherwise;\n    this.refs = [].concat(refs);\n    then = callOrConcat(then);\n    otherwise = callOrConcat(otherwise);\n    if (typeof options === 'function') this.fn = options;else {\n      if (!(0, _has.default)(options, 'is')) throw new TypeError('`is:` is required for `when()` conditions');\n      if (!options.then && !options.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');\n      var isFn = typeof is === 'function' ? is : function () {\n        for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n          values[_key] = arguments[_key];\n        }\n\n        return values.every(function (value) {\n          return value === is;\n        });\n      };\n\n      this.fn = function () {\n        for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          values[_key2] = arguments[_key2];\n        }\n\n        var currentSchema = values.pop();\n        var option = isFn.apply(void 0, values) ? then : otherwise;\n        return option(currentSchema);\n      };\n    }\n  }\n\n  var _proto = Conditional.prototype;\n\n  _proto.getValue = function getValue(parent, context) {\n    var values = this.refs.map(function (r) {\n      return r.getValue(parent, context);\n    });\n    return values;\n  };\n\n  _proto.resolve = function resolve(ctx, values) {\n    var schema = this.fn.apply(ctx, values.concat(ctx));\n    if (schema !== undefined && !(0, _isSchema.default)(schema)) throw new TypeError('conditions must return a schema object');\n    return schema || ctx;\n  };\n\n  return Conditional;\n}();\n\nvar _default = Conditional;\nexports.default = _default;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/home/tim/Documents/BasicReact/test/node_modules/yup/lib/Condition.js"],"names":["_interopRequireDefault","require","exports","__esModule","default","_has","_isSchema","callOrConcat","schema","base","concat","Conditional","refs","options","is","then","otherwise","fn","TypeError","isFn","_len","arguments","length","values","Array","_key","every","value","_len2","_key2","currentSchema","pop","option","apply","_proto","prototype","getValue","parent","context","map","r","resolve","ctx","undefined","_default","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _has = _interopRequireDefault(require(\"lodash/has\"));\n\nvar _isSchema = _interopRequireDefault(require(\"./util/isSchema\"));\n\nfunction callOrConcat(schema) {\n  if (typeof schema === 'function') return schema;\n  return function (base) {\n    return base.concat(schema);\n  };\n}\n\nvar Conditional =\n/*#__PURE__*/\nfunction () {\n  function Conditional(refs, options) {\n    var is = options.is,\n        then = options.then,\n        otherwise = options.otherwise;\n    this.refs = [].concat(refs);\n    then = callOrConcat(then);\n    otherwise = callOrConcat(otherwise);\n    if (typeof options === 'function') this.fn = options;else {\n      if (!(0, _has.default)(options, 'is')) throw new TypeError('`is:` is required for `when()` conditions');\n      if (!options.then && !options.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');\n      var isFn = typeof is === 'function' ? is : function () {\n        for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n          values[_key] = arguments[_key];\n        }\n\n        return values.every(function (value) {\n          return value === is;\n        });\n      };\n\n      this.fn = function () {\n        for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          values[_key2] = arguments[_key2];\n        }\n\n        var currentSchema = values.pop();\n        var option = isFn.apply(void 0, values) ? then : otherwise;\n        return option(currentSchema);\n      };\n    }\n  }\n\n  var _proto = Conditional.prototype;\n\n  _proto.getValue = function getValue(parent, context) {\n    var values = this.refs.map(function (r) {\n      return r.getValue(parent, context);\n    });\n    return values;\n  };\n\n  _proto.resolve = function resolve(ctx, values) {\n    var schema = this.fn.apply(ctx, values.concat(ctx));\n    if (schema !== undefined && !(0, _isSchema.default)(schema)) throw new TypeError('conditions must return a schema object');\n    return schema || ctx;\n  };\n\n  return Conditional;\n}();\n\nvar _default = Conditional;\nexports.default = _default;\nmodule.exports = exports[\"default\"];"]},"metadata":{},"sourceType":"script"}