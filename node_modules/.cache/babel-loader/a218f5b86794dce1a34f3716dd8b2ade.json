{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.getIn = getIn;\nexports.default = void 0;\n\nvar _propertyExpr = require(\"property-expr\");\n\nvar _has = _interopRequireDefault(require(\"lodash/has\"));\n\nvar trim = function trim(part) {\n  return part.substr(0, part.length - 1).substr(1);\n};\n\nfunction getIn(schema, path, value, context) {\n  var parent, lastPart, lastPartDebug; // if only one \"value\" arg then use it for both\n\n  context = context || value;\n  (0, _propertyExpr.forEach)(path, function (_part, isBracket, isArray) {\n    var part = isBracket ? trim(_part) : _part;\n\n    if (isArray || (0, _has.default)(schema, '_subType')) {\n      // we skipped an array: foo[].bar\n      var idx = isArray ? parseInt(part, 10) : 0;\n      schema = schema.resolve({\n        context: context,\n        parent: parent,\n        value: value\n      })._subType;\n\n      if (value) {\n        if (isArray && idx >= value.length) {\n          throw new Error(\"Yup.reach cannot resolve an array item at index: \" + _part + \", in the path: \" + path + \". \" + \"because there is no value at that index. \");\n        }\n\n        value = value[idx];\n      }\n    }\n\n    if (!isArray) {\n      schema = schema.resolve({\n        context: context,\n        parent: parent,\n        value: value\n      });\n      if (!(0, _has.default)(schema, 'fields') || !(0, _has.default)(schema.fields, part)) throw new Error(\"The schema does not contain the path: \" + path + \". \" + (\"(failed at: \" + lastPartDebug + \" which is a type: \\\"\" + schema._type + \"\\\") \"));\n      schema = schema.fields[part];\n      parent = value;\n      value = value && value[part];\n      lastPart = _part;\n      lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n    }\n  });\n\n  if (schema) {\n    schema = schema.resolve({\n      context: context,\n      parent: parent,\n      value: value\n    });\n  }\n\n  return {\n    schema: schema,\n    parent: parent,\n    parentPath: lastPart\n  };\n}\n\nvar reach = function reach(obj, path, value, context) {\n  return getIn(obj, path, value, context).schema;\n};\n\nvar _default = reach;\nexports.default = _default;","map":{"version":3,"sources":["/home/tim/Documents/ChairyPickerJS/node_modules/yup/lib/util/reach.js"],"names":["_interopRequireDefault","require","exports","__esModule","getIn","default","_propertyExpr","_has","trim","part","substr","length","schema","path","value","context","parent","lastPart","lastPartDebug","forEach","_part","isBracket","isArray","idx","parseInt","resolve","_subType","Error","fields","_type","parentPath","reach","obj","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.getIn = getIn;\nexports.default = void 0;\n\nvar _propertyExpr = require(\"property-expr\");\n\nvar _has = _interopRequireDefault(require(\"lodash/has\"));\n\nvar trim = function trim(part) {\n  return part.substr(0, part.length - 1).substr(1);\n};\n\nfunction getIn(schema, path, value, context) {\n  var parent, lastPart, lastPartDebug; // if only one \"value\" arg then use it for both\n\n  context = context || value;\n  (0, _propertyExpr.forEach)(path, function (_part, isBracket, isArray) {\n    var part = isBracket ? trim(_part) : _part;\n\n    if (isArray || (0, _has.default)(schema, '_subType')) {\n      // we skipped an array: foo[].bar\n      var idx = isArray ? parseInt(part, 10) : 0;\n      schema = schema.resolve({\n        context: context,\n        parent: parent,\n        value: value\n      })._subType;\n\n      if (value) {\n        if (isArray && idx >= value.length) {\n          throw new Error(\"Yup.reach cannot resolve an array item at index: \" + _part + \", in the path: \" + path + \". \" + \"because there is no value at that index. \");\n        }\n\n        value = value[idx];\n      }\n    }\n\n    if (!isArray) {\n      schema = schema.resolve({\n        context: context,\n        parent: parent,\n        value: value\n      });\n      if (!(0, _has.default)(schema, 'fields') || !(0, _has.default)(schema.fields, part)) throw new Error(\"The schema does not contain the path: \" + path + \". \" + (\"(failed at: \" + lastPartDebug + \" which is a type: \\\"\" + schema._type + \"\\\") \"));\n      schema = schema.fields[part];\n      parent = value;\n      value = value && value[part];\n      lastPart = _part;\n      lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n    }\n  });\n\n  if (schema) {\n    schema = schema.resolve({\n      context: context,\n      parent: parent,\n      value: value\n    });\n  }\n\n  return {\n    schema: schema,\n    parent: parent,\n    parentPath: lastPart\n  };\n}\n\nvar reach = function reach(obj, path, value, context) {\n  return getIn(obj, path, value, context).schema;\n};\n\nvar _default = reach;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}